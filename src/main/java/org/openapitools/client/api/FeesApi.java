/*
 * Lago API documentation
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 0.32.0-beta
 * Contact: tech@getlago.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiResponseBadRequest;
import org.openapitools.client.model.ApiResponseNotFound;
import org.openapitools.client.model.ApiResponseUnauthorized;
import org.openapitools.client.model.ApiResponseUnprocessableEntity;
import org.openapitools.client.model.FeeObject;
import org.openapitools.client.model.FeeUpdateInput;
import org.openapitools.client.model.FeesPaginated;
import java.time.OffsetDateTime;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class FeesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FeesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public FeesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for findAllFees
     * @param page Number of page (optional)
     * @param perPage Number of records per page (optional)
     * @param externalCustomerId External customer ID (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Amount currency (optional)
     * @param feeType Fee type (optional)
     * @param billableMetricCode Code of the source billable metric (optional)
     * @param paymentStatus Payment status (optional)
     * @param createdAtFrom Creation datetime from (optional)
     * @param createdAtTo Creation date to (optional)
     * @param succeededAtFrom Payment succees date from (optional)
     * @param succeededAtTo Payment succees date to (optional)
     * @param failedAtFrom Payment failed date from (optional)
     * @param failedAtTo Payment failed date to (optional)
     * @param refundedAtFrom Payment refund date from (optional)
     * @param refundedAtTo Payment refund date to (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAllFeesCall(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, String currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fees";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (externalCustomerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("external_customer_id", externalCustomerId));
        }

        if (externalSubscriptionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("external_subscription_id", externalSubscriptionId));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (feeType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fee_type", feeType));
        }

        if (billableMetricCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("billable_metric_code", billableMetricCode));
        }

        if (paymentStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("payment_status", paymentStatus));
        }

        if (createdAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at_from", createdAtFrom));
        }

        if (createdAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at_to", createdAtTo));
        }

        if (succeededAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("succeeded_at_from", succeededAtFrom));
        }

        if (succeededAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("succeeded_at_to", succeededAtTo));
        }

        if (failedAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("failed_at_from", failedAtFrom));
        }

        if (failedAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("failed_at_to", failedAtTo));
        }

        if (refundedAtFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("refunded_at_from", refundedAtFrom));
        }

        if (refundedAtTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("refunded_at_to", refundedAtTo));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findAllFeesValidateBeforeCall(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, String currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback _callback) throws ApiException {
        return findAllFeesCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, _callback);

    }

    /**
     * Find all fees
     * Find all fees of an organization and filter them
     * @param page Number of page (optional)
     * @param perPage Number of records per page (optional)
     * @param externalCustomerId External customer ID (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Amount currency (optional)
     * @param feeType Fee type (optional)
     * @param billableMetricCode Code of the source billable metric (optional)
     * @param paymentStatus Payment status (optional)
     * @param createdAtFrom Creation datetime from (optional)
     * @param createdAtTo Creation date to (optional)
     * @param succeededAtFrom Payment succees date from (optional)
     * @param succeededAtTo Payment succees date to (optional)
     * @param failedAtFrom Payment failed date from (optional)
     * @param failedAtTo Payment failed date to (optional)
     * @param refundedAtFrom Payment refund date from (optional)
     * @param refundedAtTo Payment refund date to (optional)
     * @return FeesPaginated
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public FeesPaginated findAllFees(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, String currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo) throws ApiException {
        ApiResponse<FeesPaginated> localVarResp = findAllFeesWithHttpInfo(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo);
        return localVarResp.getData();
    }

    /**
     * Find all fees
     * Find all fees of an organization and filter them
     * @param page Number of page (optional)
     * @param perPage Number of records per page (optional)
     * @param externalCustomerId External customer ID (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Amount currency (optional)
     * @param feeType Fee type (optional)
     * @param billableMetricCode Code of the source billable metric (optional)
     * @param paymentStatus Payment status (optional)
     * @param createdAtFrom Creation datetime from (optional)
     * @param createdAtTo Creation date to (optional)
     * @param succeededAtFrom Payment succees date from (optional)
     * @param succeededAtTo Payment succees date to (optional)
     * @param failedAtFrom Payment failed date from (optional)
     * @param failedAtTo Payment failed date to (optional)
     * @param refundedAtFrom Payment refund date from (optional)
     * @param refundedAtTo Payment refund date to (optional)
     * @return ApiResponse&lt;FeesPaginated&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FeesPaginated> findAllFeesWithHttpInfo(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, String currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo) throws ApiException {
        okhttp3.Call localVarCall = findAllFeesValidateBeforeCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, null);
        Type localVarReturnType = new TypeToken<FeesPaginated>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find all fees (asynchronously)
     * Find all fees of an organization and filter them
     * @param page Number of page (optional)
     * @param perPage Number of records per page (optional)
     * @param externalCustomerId External customer ID (optional)
     * @param externalSubscriptionId External subscription ID (optional)
     * @param currency Amount currency (optional)
     * @param feeType Fee type (optional)
     * @param billableMetricCode Code of the source billable metric (optional)
     * @param paymentStatus Payment status (optional)
     * @param createdAtFrom Creation datetime from (optional)
     * @param createdAtTo Creation date to (optional)
     * @param succeededAtFrom Payment succees date from (optional)
     * @param succeededAtTo Payment succees date to (optional)
     * @param failedAtFrom Payment failed date from (optional)
     * @param failedAtTo Payment failed date to (optional)
     * @param refundedAtFrom Payment refund date from (optional)
     * @param refundedAtTo Payment refund date to (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAllFeesAsync(Integer page, Integer perPage, String externalCustomerId, String externalSubscriptionId, String currency, String feeType, String billableMetricCode, String paymentStatus, OffsetDateTime createdAtFrom, OffsetDateTime createdAtTo, OffsetDateTime succeededAtFrom, OffsetDateTime succeededAtTo, OffsetDateTime failedAtFrom, OffsetDateTime failedAtTo, OffsetDateTime refundedAtFrom, OffsetDateTime refundedAtTo, final ApiCallback<FeesPaginated> _callback) throws ApiException {

        okhttp3.Call localVarCall = findAllFeesValidateBeforeCall(page, perPage, externalCustomerId, externalSubscriptionId, currency, feeType, billableMetricCode, paymentStatus, createdAtFrom, createdAtTo, succeededAtFrom, succeededAtTo, failedAtFrom, failedAtTo, refundedAtFrom, refundedAtTo, _callback);
        Type localVarReturnType = new TypeToken<FeesPaginated>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findFee
     * @param id ID of the existing Lago Fee (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findFeeCall(UUID id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fees/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findFeeValidateBeforeCall(UUID id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling findFee(Async)");
        }

        return findFeeCall(id, _callback);

    }

    /**
     * Find fee by ID
     * Return a single fee
     * @param id ID of the existing Lago Fee (required)
     * @return FeeObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public FeeObject findFee(UUID id) throws ApiException {
        ApiResponse<FeeObject> localVarResp = findFeeWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Find fee by ID
     * Return a single fee
     * @param id ID of the existing Lago Fee (required)
     * @return ApiResponse&lt;FeeObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FeeObject> findFeeWithHttpInfo(UUID id) throws ApiException {
        okhttp3.Call localVarCall = findFeeValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<FeeObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find fee by ID (asynchronously)
     * Return a single fee
     * @param id ID of the existing Lago Fee (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findFeeAsync(UUID id, final ApiCallback<FeeObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = findFeeValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<FeeObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateFee
     * @param id ID of the existing Lago Fee (required)
     * @param feeUpdateInput Payload to update a fee (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateFeeCall(UUID id, FeeUpdateInput feeUpdateInput, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = feeUpdateInput;

        // create path and map variables
        String localVarPath = "/fees/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateFeeValidateBeforeCall(UUID id, FeeUpdateInput feeUpdateInput, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateFee(Async)");
        }

        return updateFeeCall(id, feeUpdateInput, _callback);

    }

    /**
     * Update an existing fee
     * Update an existing fee
     * @param id ID of the existing Lago Fee (required)
     * @param feeUpdateInput Payload to update a fee (optional)
     * @return FeeObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public FeeObject updateFee(UUID id, FeeUpdateInput feeUpdateInput) throws ApiException {
        ApiResponse<FeeObject> localVarResp = updateFeeWithHttpInfo(id, feeUpdateInput);
        return localVarResp.getData();
    }

    /**
     * Update an existing fee
     * Update an existing fee
     * @param id ID of the existing Lago Fee (required)
     * @param feeUpdateInput Payload to update a fee (optional)
     * @return ApiResponse&lt;FeeObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FeeObject> updateFeeWithHttpInfo(UUID id, FeeUpdateInput feeUpdateInput) throws ApiException {
        okhttp3.Call localVarCall = updateFeeValidateBeforeCall(id, feeUpdateInput, null);
        Type localVarReturnType = new TypeToken<FeeObject>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an existing fee (asynchronously)
     * Update an existing fee
     * @param id ID of the existing Lago Fee (required)
     * @param feeUpdateInput Payload to update a fee (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request error </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized error </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateFeeAsync(UUID id, FeeUpdateInput feeUpdateInput, final ApiCallback<FeeObject> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateFeeValidateBeforeCall(id, feeUpdateInput, _callback);
        Type localVarReturnType = new TypeToken<FeeObject>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
